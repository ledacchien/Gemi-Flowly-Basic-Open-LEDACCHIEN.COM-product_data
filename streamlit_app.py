import streamlit as st
from streamlit.components.v1 import html
from openai import OpenAI, OpenAIError
import os
import glob
import json
import re

# --- C√ÅC H√ÄM TI·ªÜN √çCH ---
def rfile(name_file):
    """ƒê·ªçc n·ªôi dung t·ª´ m·ªôt file v√† tr·∫£ v·ªÅ d∆∞·ªõi d·∫°ng chu·ªói."""
    try:
        with open(name_file, "r", encoding="utf-8") as file:
            return file.read().strip()
    except Exception:
        return ""

def load_config_data(config_file, default_data):
    """T·∫£i d·ªØ li·ªáu c·∫•u h√¨nh t·ª´ file, n·∫øu l·ªói th√¨ d√πng d·ªØ li·ªáu m·∫∑c ƒë·ªãnh."""
    try:
        with open(config_file, "r", encoding="utf-8") as file:
            lines = [line.strip() for line in file if line.strip() and not line.startswith('#')]
            while len(lines) < len(default_data):
                lines.append(default_data[len(lines)])
            return lines[:len(default_data)]
    except Exception:
        return default_data

# --- C√ÅC H√ÄM X·ª¨ L√ù D·ªÆ LI·ªÜU ---

@st.cache_data(ttl=600)
def get_all_products_as_dicts(folder_path="product_data"):
    """
    T·∫£i t·∫•t c·∫£ s·∫£n ph·∫©m, chuy·ªÉn ƒë·ªïi th√†nh danh s√°ch c√°c dictionary.
    Code s·∫Ω t·ª± ƒë·ªông c·ªë g·∫Øng chuy·ªÉn c√°c gi√° tr·ªã c√≥ d·∫°ng s·ªë th√†nh ki·ªÉu s·ªë ƒë·ªÉ so s√°nh.
    """
    product_index = []
    if not os.path.isdir(folder_path):
        return []
    
    file_paths = [f for f in glob.glob(os.path.join(folder_path, '*.txt')) if not os.path.basename(f) == '_link.txt']
    
    for file_path in file_paths:
        content = rfile(file_path)
        if not content: continue
            
        product_dict = {}
        for line in content.split('\n'):
            if ':' in line:
                key, value_str = line.split(':', 1)
                key_clean = key.strip()
                value_clean = value_str.strip()
                
                # C·ªë g·∫Øng chuy·ªÉn ƒë·ªïi gi√° tr·ªã th√†nh s·ªë (float) n·∫øu c√≥ th·ªÉ.
                try:
                    # Lo·∫°i b·ªè c√°c k√Ω t·ª± kh√¥ng ph·∫£i s·ªë (tr·ª´ d·∫•u ch·∫•m)
                    numerical_part = re.sub(r'[^\d.]', '', value_clean)
                    if numerical_part:
                        product_dict[key_clean] = float(numerical_part)
                    else: # N·∫øu kh√¥ng c√≥ ph·∫ßn s·ªë, gi·ªØ nguy√™n chu·ªói
                        product_dict[key_clean] = value_clean
                except (ValueError, TypeError):
                    product_dict[key_clean] = value_clean # Gi·ªØ nguy√™n n·∫øu chuy·ªÉn ƒë·ªïi l·ªói
        
        product_dict['original_content'] = content # Gi·ªØ l·∫°i n·ªôi dung g·ªëc
        if product_dict:
            product_index.append(product_dict)
    return product_index

# --- C√ÅC C√îNG C·ª§ CHUY√äN D·ª§NG CHO AI (LOGIC B·∫∞NG PYTHON) ---

def find_products(product_type: str = None, sort_key: str = None, sort_order: str = 'desc', n_results: int = 1):
    """
    T√¨m ki·∫øm, l·ªçc v√† s·∫Øp x·∫øp s·∫£n ph·∫©m ƒë·ªÉ tr·∫£ l·ªùi c√°c c√¢u h·ªèi nh∆∞ 'cƒÉn h·ªô r·∫ª nh·∫•t', '3 bi·ªát th·ª± r·ªông nh·∫•t'.
    C√¥ng c·ª• n√†y x·ª≠ l√Ω logic so s√°nh m·ªôt c√°ch ch√≠nh x√°c b·∫±ng code Python.
    """
    all_products = get_all_products_as_dicts()

    products_to_process = all_products
    if product_type:
        products_to_process = [p for p in all_products if p.get("loai_san_pham", "").lower() == product_type.lower()]

    if not products_to_process:
        return "Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m n√†o thu·ªôc lo·∫°i n√†y."

    if sort_key:
        valid_products = [p for p in products_to_process if isinstance(p.get(sort_key), (int, float))]
        if not valid_products:
            return f"Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá ƒë·ªÉ s·∫Øp x·∫øp theo '{sort_key}'."
            
        is_descending = sort_order == 'desc'
        sorted_products = sorted(valid_products, key=lambda x: x[sort_key], reverse=is_descending)
        
        # X·ª≠ l√Ω tr∆∞·ªùng h·ª£p c√≥ nhi·ªÅu s·∫£n ph·∫©m b·∫±ng nhau ·ªü top
        if n_results == 1 and len(sorted_products) > 0:
            top_value = sorted_products[0][sort_key]
            top_products = [p for p in sorted_products if p.get(sort_key) == top_value]
            return [p.get('original_content', '') for p in top_products]

        return [p.get('original_content', '') for p in sorted_products[:n_results]]

    return [p.get('original_content', '') for p in products_to_process[:n_results]]

def count_products_by_type(product_type: str = None):
    """ƒê·∫øm ch√≠nh x√°c s·ªë l∆∞·ª£ng s·∫£n ph·∫©m."""
    all_products = get_all_products_as_dicts()
    if not product_type:
        return {"total_count": len(all_products)}
    count = sum(1 for p in all_products if p.get("loai_san_pham", "").lower() == product_type.lower())
    return {f"count_of_{product_type.lower()}": count}

# --- LOGIC CHATBOT ---
def show_chatbot():
    openai_api_key = st.secrets.get("OPENAI_API_KEY")
    if not openai_api_key: st.error("Ch∆∞a c√≥ OpenAI API Key."); return
    try:
        client = OpenAI(api_key=openai_api_key)
    except OpenAIError as e:
        st.error(f"L·ªói x√°c th·ª±c OpenAI API Key: {e}."); return

    tools = [
        {"type": "function", "function": {"name": "find_products", "description": "T√¨m ki·∫øm, l·ªçc v√† s·∫Øp x·∫øp s·∫£n ph·∫©m. D√πng cho c√°c c√¢u h·ªèi nh∆∞ 'cƒÉn h·ªô r·∫ª nh·∫•t', 'bi·ªát th·ª± r·ªông nh·∫•t', 'top 3 gi√° cao nh·∫•t'.", "parameters": {"type": "object", "properties": {"product_type": {"type": "string", "description": "Lo·∫°i s·∫£n ph·∫©m c·∫ßn t√¨m, v√≠ d·ª•: 'cƒÉn h·ªô', 'bi·ªát th·ª±'."},"sort_key": {"type": "string", "description": "Thu·ªôc t√≠nh ƒë·ªÉ s·∫Øp x·∫øp. V√≠ d·ª•: 'gia_thue' cho gi√°, 'dien_tich' cho di·ªán t√≠ch."}, "sort_order": {"type": "string", "enum": ["asc", "desc"], "description": "'asc' cho tƒÉng d·∫ßn (r·∫ª nh·∫•t, h·∫πp nh·∫•t), 'desc' cho gi·∫£m d·∫ßn (ƒë·∫Øt nh·∫•t, r·ªông nh·∫•t)."}, "n_results": {"type": "integer", "description": "S·ªë l∆∞·ª£ng k·∫øt qu·∫£ tr·∫£ v·ªÅ."}}}}},
        {"type": "function", "function": {"name": "count_products_by_type", "description": "ƒê·∫øm ch√≠nh x√°c t·ªïng s·ªë s·∫£n ph·∫©m ho·∫∑c s·ªë s·∫£n ph·∫©m theo lo·∫°i.", "parameters": {"type": "object", "properties": {"product_type": {"type": "string", "description": "Lo·∫°i s·∫£n ph·∫©m c·∫ßn ƒë·∫øm. ƒê·ªÉ tr·ªëng ƒë·ªÉ ƒë·∫øm t·∫•t c·∫£."}}}}}
    ]

    if "messages" not in st.session_state:
        st.session_state.messages = [{"role": "assistant", "content": rfile("02.assistant.txt") or "T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?"}]

    for message in st.session_state.messages:
        with st.chat_message(message["role"]): st.markdown(message["content"])

    if prompt := st.chat_input("B·∫°n nh·∫≠p n·ªôi dung c·∫ßn trao ƒë·ªïi ·ªü ƒë√¢y nh√©?"):
        st.session_state.messages.append({"role": "user", "content": prompt})
        st.rerun()

    if st.session_state.messages and st.session_state.messages[-1]["role"] == "user":
        
        system_prompt = rfile("01.system_trainning.txt")
        messages_to_send = [{"role": "system", "content": system_prompt}] + st.session_state.messages

        with st.chat_message("assistant"):
            with st.spinner("Tr·ª£ l√Ω ƒëang suy nghƒ©..."):
                try:
                    response = client.chat.completions.create(
                        model=rfile("module_chatgpt.txt").strip() or "gpt-4-turbo",
                        messages=messages_to_send, tools=tools, tool_choice="auto"
                    )
                    response_message = response.choices[0].message
                    tool_calls = response_message.tool_calls

                    if tool_calls:
                        available_functions = {"find_products": find_products, "count_products_by_type": count_products_by_type}
                        messages_to_send.append(response_message)
                        for tool_call in tool_calls:
                            function_name = tool_call.function.name
                            function_args = json.loads(tool_call.function.arguments)
                            function_to_call = available_functions[function_name]
                            function_response = function_to_call(**function_args)
                            messages_to_send.append({"tool_call_id": tool_call.id, "role": "tool", "name": function_name, "content": json.dumps(function_response, ensure_ascii=False)})
                        
                        second_response = client.chat.completions.create(model=rfile("module_chatgpt.txt").strip() or "gpt-4-turbo", messages=messages_to_send, stream=True)
                        final_response = st.write_stream(second_response)
                        st.session_state.messages.append({"role": "assistant", "content": final_response})
                    else:
                        st.markdown(response_message.content)
                        st.session_state.messages.append({"role": "assistant", "content": response_message.content})
                except OpenAIError as e:
                    st.error(f"ƒê√£ x·∫£y ra l·ªói v·ªõi OpenAI: {e}")

# --- C√ÅC H√ÄM C√íN L·∫†I ---
def check_login():
    if st.session_state.get("authenticated", False): return True
    st.title("üîê ƒêƒÉng nh·∫≠p v√†o ·ª©ng d·ª•ng")
    with st.form("login_form"):
        username = st.text_input("T√™n ƒëƒÉng nh·∫≠p")
        password = st.text_input("M·∫≠t kh·∫©u", type="password")
        if st.form_submit_button("ƒêƒÉng nh·∫≠p"):
            correct_username, correct_password = st.secrets.get("USERNAME"), st.secrets.get("PASSWORD")
            if not correct_username or not correct_password:
                st.error("L·ªói: Th√¥ng tin ƒëƒÉng nh·∫≠p ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p tr√™n server.")
                return False
            if username == correct_username and password == correct_password:
                st.session_state["authenticated"] = True
                st.rerun()
            else:
                st.error("T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ch√≠nh x√°c.")
    return False

def show_main_page():
    st.subheader("‚ú® C√°c b√†i vi·∫øt n·ªïi b·∫≠t")
    default_images = ["article_images/pic1.jpg", "article_images/pic2.jpg", "article_images/pic3.jpg"]
    default_titles = ["Ti√™u ƒë·ªÅ b√†i vi·∫øt 1", "Ti√™u ƒë·ªÅ b√†i vi·∫øt 2", "Ti√™u ƒë·ªÅ b√†i vi·∫øt 3"]
    image_paths = [path if os.path.exists(path) else f"https://placehold.co/400x267/a3e635/44403c?text=Thi·∫øu+·∫£nh+{i+1}" for i, path in enumerate(default_images)]
    article_titles = load_config_data("config_titles.txt", default_titles)
    col1, col2, col3 = st.columns(3, gap="medium")
    for i, col in enumerate([col1, col2, col3]):
        with col:
            st.image(image_paths[i], use_container_width=True)
            if st.button(article_titles[i], use_container_width=True, key=f"btn{i+1}"):
                st.session_state.view = f"article_{i+1}"
                st.rerun()
    st.divider()
    if os.path.exists("logo.png"): st.image("logo.png")
    st.markdown(f"<h2 style='text-align: center;'>{rfile('00.xinchao.txt') or 'Ch√†o m·ª´ng ƒë·∫øn v·ªõi Tr·ª£ l√Ω AI'}</h2>", unsafe_allow_html=True)
    show_chatbot()

def show_article_page(article_number):
    if st.button("‚¨ÖÔ∏è Quay v·ªÅ Trang ch·ªß"): st.session_state.view = "main"; st.rerun()
    st.divider()
    try:
        with open(f"03bai_viet/bai_viet_0{article_number}.html", "r", encoding="utf-8") as f:
            html(f.read(), height=800, scrolling=True)
    except FileNotFoundError:
        st.error(f"L·ªói: Kh√¥ng t√¨m th·∫•y file b√†i vi·∫øt s·ªë {article_number}.")

def main():
    st.set_page_config(page_title="Tr·ª£ l√Ω AI", page_icon="ü§ñ", layout="centered")
    st.markdown("""<style>
        [data-testid="stToolbar"], header, #MainMenu {visibility: hidden !important;}
        div[data-testid="stHorizontalBlock"]:has(div[data-testid="stChatMessageContent-user"]) { justify-content: flex-end; }
        div[data-testid="stChatMessage"]:has(div[data-testid="stChatMessageContent-user"]) { flex-direction: row-reverse; }
        .st-emotion-cache-1v0mbdj > div > div > div > div > div[data-testid="stVerticalBlock"] .stImage { height: 150px; width: 100%; overflow: hidden; border-radius: 0.5rem; }
        .st-emotion-cache-1v0mbdj > div > div > div > div > div[data-testid="stVerticalBlock"] .stImage img { height: 100%; width: 100%; object-fit: cover; }
    </style>""", unsafe_allow_html=True) 
    if not check_login(): return
    with st.sidebar:
        st.success("‚úÖ ƒê√£ ƒëƒÉng nh·∫≠p")
        if st.button("ƒêƒÉng xu·∫•t"):
            for key in ["authenticated", "messages", "view"]:
                if key in st.session_state: del st.session_state[key]
            st.rerun()
    if "view" not in st.session_state: st.session_state.view = "main"
    view_map = {"main": show_main_page, "article_1": lambda: show_article_page(1), "article_2": lambda: show_article_page(2), "article_3": lambda: show_article_page(3)}
    view_map.get(st.session_state.view, show_main_page)()

if __name__ == "__main__":
    main()
